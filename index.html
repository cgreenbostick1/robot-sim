<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Human-Robot EEG Simulation</title>
  <style>
    body { margin:0; display:flex; height:100vh; font-family:Arial,Helvetica,sans-serif; }

    /* RIGHT: fixed-width sidebar for 3D + controls */
    #left {
      flex: 0 0 420px;
      width: 420px;
      min-width: 420px;
      display:flex;
      flex-direction:column;
      border-left:1px solid #ddd;  /* divider */
      background:#fff;
    }
    #canvasContainer { flex: 1; background:#eef; }
    #controls { padding:10px; background:#f4f4f4; border-top:1px solid #ddd; }

    /* LEFT: big chart area (white background) */
    #chartContainer {
      flex: 1;
      width: auto;
      padding:10px;
      background:#fff;            /* white, as requested */
    }
    h4 { margin:0 0 8px 0; color:#222; }
    #chartContainer p { color:#555; }
    #chart { background:#fff; }   /* ensure the canvas itself is white */

    canvas { display:block; }
  </style>
</head>
<body>
  <!-- RIGHT (fixed 420px): 3D + controls -->
  <div id="left">
    <div id="canvasContainer"></div>
    <div id="controls">
      <label>Task Difficulty:
        <input id="difficulty" type="range" min="0" max="3" step="0.1" value="1">
      </label>
      <button id="toggle">Pause Simulation</button>
    </div>
  </div>

  <!-- LEFT (flex:1): Big chart area -->
  <div id="chartContainer">
    <h4>Simulated EEG / Affect Signals</h4>
    <canvas id="chart"></canvas>
    <p style="font-size:13px;">Blue = Focus | Orange = Stress | Green = Engagement</p>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

  <script>
  /* --------------------- THREE.JS (RIGHT SIDEBAR) --------------------- */
  const container = document.getElementById('canvasContainer');
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);

  const renderer = new THREE.WebGLRenderer({ antialias: true });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  container.appendChild(renderer.domElement);

  // Camera & background
  camera.position.set(4, 3, 6);
  camera.lookAt(0, 1, 0);
  renderer.setClearColor(0xf0f0f0); // light gray looks nice against white page

  function resize3D(){
    const w = container.clientWidth, h = container.clientHeight || 1;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  resize3D();
  if (window.ResizeObserver) new ResizeObserver(resize3D).observe(container);
  window.addEventListener('resize', resize3D);

  // Lights
  scene.add(new THREE.AmbientLight(0x888888));
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(5,10,5);
  scene.add(light);

  // Simple robot
  const base = new THREE.Mesh(
    new THREE.BoxGeometry(1, 0.2, 1),
    new THREE.MeshStandardMaterial({ color: 0x2b6f77 })
  );
  base.position.y = 0.1; scene.add(base);

  const arm = new THREE.Mesh(
    new THREE.BoxGeometry(0.3, 1.5, 0.3),
    new THREE.MeshStandardMaterial({ color: 0x1565c0 })
  );
  arm.position.y = 0.75; base.add(arm);

  const gripper = new THREE.Mesh(
    new THREE.BoxGeometry(0.8, 0.1, 0.2),
    new THREE.MeshStandardMaterial({ color: 0x222222 })
  );
  gripper.position.y = 0.9; arm.add(gripper);

  if (THREE.OrbitControls) {
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    (function tick(){ controls.update(); requestAnimationFrame(tick); })();
  }

  /* --------------------- CHART (LEFT BIG PANE) --------------------- */
  const ctx = document.getElementById('chart').getContext('2d');
  const MAX_POINTS = 60;
  const chart = new Chart(ctx, {
    type: 'line',
    data: {
      labels: Array(MAX_POINTS).fill(""),
      datasets: [
        { label: 'Focus',      data: Array(MAX_POINTS).fill(0.5), borderColor: 'blue',   fill: false, tension: 0.2 },
        { label: 'Stress',     data: Array(MAX_POINTS).fill(0.5), borderColor: 'orange', fill: false, tension: 0.2 },
        { label: 'Engagement', data: Array(MAX_POINTS).fill(0.5), borderColor: 'green',  fill: false, tension: 0.2 }
      ]
    },
    options: {
      responsive: false,            // we'll size it to fill the pane
      maintainAspectRatio: false,
      animation: false,
      scales: { y: { min: 0, max: 1 } },
      plugins: { legend: { display: true } }
    }
  });

  // Fill the big pane
  function sizeChartCanvas(){
    const parent = document.getElementById('chartContainer');
    // leave some room for title/legend
    const titleH = 28, legendH = 22, pad = 16;
    const c = document.getElementById('chart');
    c.width  = parent.clientWidth  - pad;
    c.height = Math.max(150, parent.clientHeight - titleH - legendH - pad);
    chart.resize();
  }
  sizeChartCanvas();
  if (window.ResizeObserver) new ResizeObserver(sizeChartCanvas).observe(document.getElementById('chartContainer'));
  window.addEventListener('resize', sizeChartCanvas);

  /* --------------------- SIMULATION --------------------- */
  let running = true;
  document.getElementById('toggle').onclick = () => {
    running = !running;
    document.getElementById('toggle').textContent = running ? "Pause Simulation" : "Resume Simulation";
  };

  function simulateEEG(t, difficulty){
    const focus   = 0.5 + 0.3*Math.sin(t*0.002) - 0.05*difficulty;
    const stress  = 0.4 + 0.4*Math.cos(t*0.0015 + difficulty);
    const engage  = 0.6 + 0.2*Math.sin(t*0.001*difficulty + 2);
    const clamp = v => Math.max(0, Math.min(1, v));
    return [clamp(focus), clamp(stress), clamp(engage)];
  }

  function animate(time){
    requestAnimationFrame(animate);
    if (running) {
      const diff = parseFloat(document.getElementById('difficulty').value);
      base.rotation.y      += 0.005 * diff;
      arm.rotation.z        = 0.3 * Math.sin(time * 0.001 * diff);
      gripper.rotation.x    = 0.2 * Math.sin(time * 0.002 * diff);

      const [f,s,e] = simulateEEG(time, diff);
      chart.data.datasets[0].data.push(f);
      chart.data.datasets[1].data.push(s);
      chart.data.datasets[2].data.push(e);
      chart.data.datasets.forEach(ds => { if (ds.data.length > MAX_POINTS) ds.data.shift(); });
      chart.update("none");
    }
    renderer.render(scene, camera);
  }
  animate(0);
  </script>
</body>
</html>


