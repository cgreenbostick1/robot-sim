<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Human-Robot EEG Simulation</title>
  <style>
    body { margin:0; display:flex; height:100vh; font-family:Arial,Helvetica,sans-serif; background:#fff; }

    /* LEFT: big chart area (white) */
    #chartPane{
      flex:1; display:flex; flex-direction:column;
      padding:16px; gap:8px; background:#fff; min-width:0;
    }
    #chartPane h4{ margin:0; color:#222; }
    #legend{ margin:0; color:#555; font-size:13px; }
    #chartWrap{
      flex:1; background:#fff; border:1px solid #e5e7eb;
      border-radius:8px; padding:10px; overflow:hidden;
    }
    #chart{ background:#fff; display:block; }

    /* RIGHT: fixed sidebar for 3D + controls (blue) */
    #right{
      width:420px; min-width:420px; display:flex; flex-direction:column;
      background:#174f96; border-left:1px solid #0f3570;
    }
    #canvasContainer{ flex:1; }
    #controls{ padding:10px; background:#0f3570; border-top:1px solid #0a2855; color:#dfe8ff; }
    #controls label { margin-right:10px; }

    canvas { display:block; }
  </style>
</head>
<body>

  <!-- LEFT (chart) -->
  <div id="chartPane">
    <h4>Simulated EEG / Affect Signals</h4>
    <div id="chartWrap">
      <canvas id="chart"></canvas>
    </div>
    <p id="legend">
      Blue = Focus | Orange = Stress | Green = Engagement |
      Purple = Interest | Red = Excitement | Teal = Relaxation
    </p>
  </div>

  <!-- RIGHT (3D headset + controls) -->
  <div id="right">
    <div id="canvasContainer"></div>
    <div id="controls">
      <label>Task Difficulty:
        <input id="difficulty" type="range" min="0" max="3" step="0.1" value="1">
      </label>
      <button id="toggle">Pause Simulation</button>
    </div>
  </div>

  <!-- Libraries -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.152.2/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>

  <script>
  /* --------------------- THREE.JS (RIGHT SIDEBAR) --------------------- */
  const container = document.getElementById('canvasContainer');
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);

  const renderer = new THREE.WebGLRenderer({ antialias:true });
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  container.appendChild(renderer.domElement);

  // Blue background to match sidebar (so if nothing renders you still see blue, not black)
  renderer.setClearColor(0x174f96);

  camera.position.set(0, 1.2, 4);
  camera.lookAt(0, 0.9, 0);

  function resize3D(){
    const w = container.clientWidth, h = container.clientHeight || 1;
    renderer.setSize(w, h, false);
    camera.aspect = w / h;
    camera.updateProjectionMatrix();
  }
  resize3D();
  if (window.ResizeObserver) new ResizeObserver(resize3D).observe(container);
  window.addEventListener('resize', resize3D);

  // Lights (brighter so the model isn't too dark)
  scene.add(new THREE.AmbientLight(0x999999));
  const keyLight = new THREE.DirectionalLight(0xffffff, 1.1); keyLight.position.set(4, 6, 8); scene.add(keyLight);
  const rimLight = new THREE.DirectionalLight(0x9bd1ff, 0.7); rimLight.position.set(-6, 4, -3); scene.add(rimLight);

  // ---------- Stylized 3D Headset (safe primitives only) ----------
  const headset = new THREE.Group(); scene.add(headset);
  const metal = new THREE.MeshStandardMaterial({ color: 0x222428, metalness: 0.6, roughness: 0.35 });
  const matte = new THREE.MeshStandardMaterial({ color: 0x2b6f77, metalness: 0.2, roughness: 0.8 });
  const foam  = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, metalness: 0.1, roughness: 0.9 });

  try {
    // Headband: half torus
    const band = new THREE.Mesh(new THREE.TorusGeometry(1.2, 0.08, 16, 100, Math.PI), metal);
    band.rotation.x = Math.PI / 2; band.position.y = 1.2; headset.add(band);

    // Top cushion
    const cushion = new THREE.Mesh(new THREE.BoxGeometry(1.4, 0.15, 0.1), foam);
    cushion.position.set(0, 1.25, 0); headset.add(cushion);

    // Ear cups + pads
    const cupGeom = new THREE.CylinderGeometry(0.45, 0.45, 0.25, 24);
    const cupL = new THREE.Mesh(cupGeom, metal); cupL.rotation.z = Math.PI / 2; cupL.position.set(-0.95, 0.7, 0); headset.add(cupL);
    const padL = new THREE.Mesh(new THREE.TorusGeometry(0.45, 0.08, 12, 24), foam); padL.rotation.y = Math.PI / 2; padL.position.set(-0.95, 0.7, 0); headset.add(padL);
    const cupR = cupL.clone(); cupR.position.x = 0.95; headset.add(cupR);
    const padR = padL.clone(); padR.position.x = 0.95; headset.add(padR);

    // Arms
    const armGeom = new THREE.BoxGeometry(0.08, 0.6, 0.08);
    const armL = new THREE.Mesh(armGeom, matte); armL.position.set(-0.95, 1.0, 0); headset.add(armL);
    const armR = armL.clone(); armR.position.x = 0.95; headset.add(armR);

    // Mic boom (safe: cylinder + sphere tip)
    const micGroup = new THREE.Group(); headset.add(micGroup);
    const micRod = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.9, 16), matte);
    micRod.rotation.z = -Math.PI / 3; micRod.position.set(0.2, 0.55, 0.35); micGroup.add(micRod);
    const micTip = new THREE.Mesh(new THREE.SphereGeometry(0.06, 16, 12), metal);
    micTip.position.set(0.2 + 0.45*Math.cos(Math.PI/3), 0.55 - 0.45*Math.sin(Math.PI/3), 0.35); micGroup.add(micTip);

    // Simple stand
    const standBase = new THREE.Mesh(new THREE.CylinderGeometry(0.9, 0.9, 0.1, 32), new THREE.MeshStandardMaterial({ color: 0x0e2f5e, metalness: 0.1, roughness: 0.9 }));
    standBase.position.y = 0.05; scene.add(standBase);
    const standPost = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.06, 1.1, 16), metal);
    standPost.position.y = 0.6; scene.add(standPost);

    // Save mic group for animation
    window.__micGroup = micGroup;

  } catch (e) {
    // Fallback (spinning cube) if any geometry causes trouble
    const cube = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshStandardMaterial({ color: 0xff5555 }));
    scene.add(cube);
    headset.add(cube);
  }

  if (THREE.OrbitControls) {
    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    (function tick(){ controls.update(); requestAnimationFrame(tick); })();
  }

  /* --------------------- CHART (LEFT BIG PANE) --------------------- */
  const chartCanvas = document.getElementById('chart');
  const MAX_POINTS = 60;
  const chart = new Chart(chartCanvas.getContext('2d'), {
    type: 'line',
    data: {
      labels: Array(MAX_POINTS).fill(""),
      datasets: [
        { label: 'Focus',      data: Array(MAX_POINTS).fill(0.5), borderColor:'blue',      fill:false, tension:0.2 },
        { label: 'Stress',     data: Array(MAX_POINTS).fill(0.5), borderColor:'orange',    fill:false, tension:0.2 },
        { label: 'Engagement', data: Array(MAX_POINTS).fill(0.5), borderColor:'green',     fill:false, tension:0.2 },
        { label: 'Interest',   data: Array(MAX_POINTS).fill(0.5), borderColor:'#7e57c2',   fill:false, tension:0.2 },
        { label: 'Excitement', data: Array(MAX_POINTS).fill(0.5), borderColor:'#e53935',   fill:false, tension:0.2 },
        { label: 'Relaxation', data: Array(MAX_POINTS).fill(0.5), borderColor:'#00897b',   fill:false, tension:0.2 }
      ]
    },
    options: {
      responsive: false, maintainAspectRatio: false, animation: false,
      scales: { y: { min: 0, max: 1 } },
      plugins: { legend: { display: true } }
    }
  });

  function sizeChart(){
    const wrap = document.getElementById('chartWrap');
    chartCanvas.width  = wrap.clientWidth  - 20;
    chartCanvas.height = wrap.clientHeight - 20;
    chart.resize();
  }
  sizeChart();
  if (window.ResizeObserver) new ResizeObserver(sizeChart).observe(document.getElementById('chartWrap'));
  window.addEventListener('resize', sizeChart);

  /* --------------------- SIGNAL SIMULATION --------------------- */
  const clamp01 = v => Math.max(0, Math.min(1, v));

  function simulateSignals(t, difficulty){
    const focus      = clamp01(0.5 + 0.3*Math.sin(t*0.002) - 0.05*difficulty);
    const stress     = clamp01(0.4 + 0.4*Math.cos(t*0.0015 + difficulty));
    const engage     = clamp01(0.6 + 0.2*Math.sin(t*0.001*difficulty + 2));
    const interest   = clamp01(0.5 + 0.25*Math.sin(t*0.0013 + difficulty*0.5) + 0.10*(engage - stress));
    const excitement = clamp01(0.5 + 0.35*Math.sin(t*0.003 + 1.2) + 0.05*difficulty);
    const relaxation = clamp01(0.6 - 0.30*stress + 0.10*(1 - focus));
    return [focus, stress, engage, interest, excitement, relaxation];
  }

  /* --------------------- MASTER LOOP --------------------- */
  let running = true;
  document.getElementById('toggle').onclick = () => {
    running = !running;
    document.getElementById('toggle').textContent = running ? "Pause Simulation" : "Resume Simulation";
  };

  function animate(time){
    requestAnimationFrame(animate);

    // Headset idle animation (spin + gentle bob + mic wobble)
    const t = time * 0.001;
    headset.rotation.y = t * 0.6;
    headset.position.y = 0.05 + Math.sin(t*1.5) * 0.03;
    if (window.__micGroup) window.__micGroup.rotation.y = Math.sin(t*2.2) * 0.12;

    if (running){
      const diff = parseFloat(document.getElementById('difficulty').value);

      // Update chart
      const values = simulateSignals(time, diff);
      chart.data.datasets.forEach((ds, i) => {
        ds.data.push(values[i]);
        if (ds.data.length > MAX_POINTS) ds.data.shift();
      });
      chart.update("none");
    }

    renderer.render(scene, camera);
  }
  animate(0);
  </script>
</body>
</html>



